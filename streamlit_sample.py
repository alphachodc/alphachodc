# -*- coding: utf-8 -*-
"""streamlit_sample.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cRyP6tk0fUMDrOznx3892VO1fOO6wcg0
"""

import os
from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import pandas as pd
# import numpy as np
# import streamlit as st
# import re
# import os
# import base64
# import time
# from PIL import Image
# from ast import literal_eval
# import plotly.graph_objects as go
# import flagpy as fp
# 
# page_bg_img = """
# <style>
# [data-testid="stAppViewContainer"]{
#   background-image: url("https://images.unsplash.com/photo-1431324155629-1a6deb1dec8d?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1740&q=80");
#   background-size: cover;
#   }
# [data-testid="stHeader"]{
#   background-color: rgba(0,0,0,0);
#   }
# [data-testid="stToolbar"]{
#   right: 2rem;
#   background-color: #42F328;
#   }
# </style>
# """
# 
# st.markdown(page_bg_img, unsafe_allow_html = True)
# st.markdown("""
# <style>
# [data-testid="stSidebar"]{
#   background-color: #0F0F0F;
#   color: #42F328;
#   }
# [data-testid="stMarkdownContainer"] > div > h2{
#   color: white;
#   }
# [data-testid="stMarkdownContainer"]> p{
#   color: white;
#   }
# </style>
# """, unsafe_allow_html=True)
# 
# st.markdown("""
# <style>
# [data-testid="stMetricValue"]{
#   color: #42F328;
#   font-size: 40px;
#   }
# [data-testid="stMarkdownContainer"] > div > h3 > div > span{
#   color: white;
# }
# </style>
# """, unsafe_allow_html = True)
# 
# rest_df_dt= pd.read_csv('/content/drive/MyDrive/rest_df_dt.csv')
# rest_df=pd.read_csv('/content/drive/MyDrive/rest_df.csv')
# GK_df_dt = pd.read_csv('/content/drive/MyDrive/GK_df_dt.csv',index_col=0)
# GK_df = pd.read_csv('/content/drive/MyDrive/GK_df.csv',index_col=0)
# 
# rest_df.loc[rest_df['pics'] == 'None', 'pics'] = 'https://img.a.transfermarkt.technology/portrait/header/default.jpg?lm=1'
# GK_df.loc[GK_df['pics'] == 'None', 'pics'] = 'https://img.a.transfermarkt.technology/portrait/header/default.jpg?lm=1'
# 
# rest_df_dt['cluster']=rest_df_dt['cluster'].apply(lambda x: literal_eval(x))
# rest_df['cluster']=rest_df['cluster'].apply(lambda x: literal_eval(x))
# GK_df_dt['cluster'] = GK_df_dt['cluster'].apply(lambda x: literal_eval(x))
# GK_df['cluster'] = GK_df['cluster'].apply(lambda x: literal_eval(x))
# 
# 
# def cosine_similarity(vec1, vec2):
#   a = np.array(vec1).ravel()
#   b = np.array(vec2).ravel()
#   denom = np.sqrt(np.sum(np.square(vec1))) * np.sqrt(np.sum(np.square(vec2)))
#   return np.dot(a,b) / denom
# 
# def similar_players(index, threshold):
#   similarity_scores = {}
#   for k, v in vectors.items():
#     similarity_scores[k] = cosine_similarity(vectors[index], v)
#   similarity_scores = {key: value for key, value in similarity_scores.items() if value >= threshold}
# 
#   return similarity_scores
# 
# st.sidebar.header("당신의 유망주를 찾아드립니다")
# name_list=list(rest_df['Name'].values)+list(GK_df['Name'].values)
# name_list.append('')
# player_input= st.sidebar.selectbox('게임 내 좋아하는 선수를 입력하세요: ',name_list,index=7755)#
# threshold = st.sidebar.number_input('최소 유사도를 입력해주세요 (90, 93, 95): ',0,99)
# fm_image=Image.open('/content/drive/MyDrive/scouter_image2.png')
# st.sidebar.image(fm_image)
# 
# if player_input in rest_df['Name'].values:
#   temp_df = rest_df
#   temp_df_dt = rest_df_dt
#   categories = ['Defending','Physical','Speed', 'Vision', 'Attacking','Technique','Aerial','Mental']
# 
#   def skill_cal(youth1):
#     defending = youth1['Tackling']*0.5 + youth1['Marking']*0.25 + youth1['Positioning']*0.25
#     physical = youth1['Strength']*0.25 + youth1['Stamina']*0.25 + youth1['Balance']*0.25 + youth1['Agility']*0.25
#     speed = youth1['Acceleration']*0.5 + youth1['Pace']*0.5
#     vision = youth1['Vision']*0.33 + youth1['Flair']*0.33 + youth1['Passing']*0.34
#     attacking = youth1['Finishing']*0.34 + youth1['Off The Ball']*0.33 + youth1['Composure']*0.33
#     technique = youth1['Technique']*0.34 + youth1['First Touch']*0.33 + youth1['Dribbling']*0.33
#     aerial = youth1['Heading']*0.5 + youth1['Jumping Reach']*0.5
#     mental = (youth1['Determination'] + youth1['Decision'] + youth1['Anticipation']+ youth1['Teamwork'] + youth1['Bravery'] + youth1['Concentration'])*0.166
#     return [defending, physical, speed, vision, attacking, technique, aerial, mental]
# 
# elif player_input in GK_df['Name'].values:
#   temp_df = GK_df
#   temp_df_dt = GK_df_dt
#   categories = ['Distribution','Eccentricity','Mental','Shot Stopping','Physical','Speed','Aerial','Communication']
# 
#   def skill_cal(youth1):
#     distribution = youth1['Passing']*0.25 + youth1['Vision']*0.25 + youth1['Kicking(GK)']*0.25 + youth1['Throwing(GK)']*0.25
#     eccentricity = youth1['Aggression']*0.2 + youth1['Eccentricity(GK)']*0.8
#     mental = (youth1['Anticipation'] + youth1['Bravery'] + youth1['Concentration'] +
#     youth1['Determination'] + youth1['Teamwork'] + youth1['Decision']) *0.166
#     shot_stopping = youth1['Reflexes(GK)']*0.3 + youth1['One On Ones(GK)']*0.3 + youth1['Handling(GK)']*0.2 + youth1['Punching(GK)']*0.2
#     physical = youth1['Agility']*0.3 + youth1['Balance']*0.2 + youth1['Natural Fitness']*0.2 + youth1['Work Rate']*0.2 + youth1['Stamina']*0.1
#     speed = youth1['Rushing Out(GK)']*0.6 + youth1['Pace']*0.4
#     aerial = youth1['Aerial Reach(GK)']*0.8 + youth1['Jumping Reach']*0.2
#     communication =  youth1['Communication(GK)']*0.7 + youth1['Command Of Area(GK)']*0.3
#     return [distribution, eccentricity, mental, shot_stopping, physical, speed, aerial, communication]
# 
# else:
#   raise 'Error'
# 
# # 선수에 해당하는 클러스터
# cluster = temp_df_dt[temp_df_dt['Name'] == player_input]['cluster']
# input_df = temp_df[temp_df['Name'] == player_input]
# # 선수 클러스터에 해당하는 모든 선수 (scaled)
# cl_df = temp_df_dt[temp_df_dt['cluster'].apply(lambda x: any(k in x for k in cluster.values[0]))]
# # 선수 클러스터에 해당하는 모든 선수 (original)
# original_df = temp_df[temp_df['cluster'].apply(lambda x: any(k in x for k in cluster.values[0]))]
# 
# # 필터된 데이터프레임 인덱스 초기화
# cl_df = cl_df.reset_index(drop=True)
# original_df = original_df.reset_index(drop=True)
# 
# # 플레이어 이름
# player = cl_df[cl_df['Name'] == player_input].index[0]
# 
# # 선수 능력치 배열
# cl_X = cl_df.iloc[:,1:-1].values
# 
# # 선수 이름 배열
# cl_Y = cl_df.iloc[:,0].values
# 
# # 코사인 유사도 (threshold input으로 구현해야 됨)
# vectors = {}
# for i, x in enumerate(cl_X):
#   vectors[i] = x.tolist()
# 
# threshold = threshold/100
# 
# if (threshold!=0):
#   top_sim_players = similar_players(player, threshold)
#   top_players = {}
#   # 선수의 코사인 유사도를 기존 선수 데이터 딕셔너리에 삽입
#   for index, similarity in top_sim_players.items():
#       info = list(original_df.iloc[index].values)
#       info.insert(1, similarity)
#       top_players[index] = info
#   lst = list(original_df.columns)
#   lst.insert(1,'similarity')
# 
#   # 유사 선수 데이터 프레임 만들기
#   output = pd.DataFrame.from_dict(data= top_players, orient = 'index', columns = lst)
#   # 연령 제한 / 능력치 제한
#   filtered_output = output[(output['Age'] <= 21) & (output['pa'] >= 130)].iloc[:,0:53]
# 
#   # 유사도 중복 기준 (소수 둘째까지 같으면 반올림)
#   def similarity_key(similarity):
#       return round(similarity, 2)
# 
#   sim = filtered_output['similarity'].apply(similarity_key)
# 
#   filtered_output.insert(1, 'sim', sim)
#   st.write('가장 플레이스타일이 비슷한 유망주는....')
# 
#   # 유사도가 중복된다면 잠재 능력치 기준으로 정렬
#   filtered_output = filtered_output.sort_values(by=['sim', 'pa'], ascending=False)
#   first_similar_player=filtered_output.iloc[0]
#   st.columns(3)[1].header(first_similar_player['Name'])
# 
#   categories = ['Defending','Physical','Speed', 'Vision', 'Attacking','Technique','Aerial','Mental']
#   gk_categories = []
# 
#   youth = filtered_output.iloc[0]
#   famous = input_df.iloc[0]
# 
#   fig = go.Figure()
# 
#   fig.add_trace(go.Scatterpolar(
#       r= skill_cal(famous),
#       theta=categories,
#       fill='toself',
#       name= f'{player_input}'))
# 
#   fig.add_trace(go.Scatterpolar(
#       r=skill_cal(youth),
#       theta=categories,
#       fill='toself',
#       opacity = 0.6,
#       marker_color = 'green',
#       fillcolor='#42F328',
#       name= f"{first_similar_player['Name']}"))
# 
#   fig.update_layout(polar=dict(radialaxis=dict(visible=True, range=[0, 20])),
#                     plot_bgcolor = 'rgba(0,0,0,0)', paper_bgcolor = 'rgba(0,0,0,0)', showlegend=False)
# 
#   pics_row = original_df.loc[original_df.Name==first_similar_player['Name'],]
#   image_adress = pics_row['pics'].values[0]
# 
#   # 다운받을 이미지 url
#   url = image_adress
# 
#   # curl 요청
#   os.system("curl " + url + " > test.jpg")
# 
#   img = Image.open("test.jpg")
# 
#   _, col2, col3 = st.columns(3)
# 
#   with col2:
#     st.image(img)
# 
#   with col3:
#     st.metric(label="유사도", value=f"{first_similar_player['sim']*100}%")
# 
#   st.columns(3)[1].subheader('나이: '+str(first_similar_player['Age']))
#   st.columns(3)[1].subheader('포지션: '+str(first_similar_player['Position']))
#   st.columns(3)[1].subheader('국적')
# 
#   flag_list = []
#   try:
#     for i in first_similar_player['Nationality'].split(','):
#       idc = fp.get_flag_img(i)
#       flag_list.append(idc)
#     st.columns(3)[1].image(flag_list, width=100)
#   except:
#     st.columns(3)[1].subheader(first_similar_player['Nationality'])
#   st.columns(3)[1].subheader('클럽: '+str(first_similar_player['Club']))
# 
#   st.plotly_chart(fig)
# 
#   video_row = original_df.loc[original_df.Name==first_similar_player['Name'],]
#   video_adress = video_row['video'].values[0]
#   try:
#     st.video(video_adress, format='video/mp4', start_time=0)
#   except:
#     st.columns(3)[1].subheader('Search on Youtube')
# 
#   temp = filtered_output[['Name','similarity','Position','Age','Nationality','Club']]
#   if len(filtered_output)>=6:
#     st.write('그 외 유사 선수목록')
#     st.table(temp.iloc[1:6].style.set_properties(**{'border': '1.5px solid #42F328','color': '#42F328'}))
#   elif len(filtered_output)==1:
#     st.write('그 외 유사선수가 존재하지 않습니다.')
#   else:
#     st.write('그 외 유사 선수목록')

!wget -q -O - ipv4.icanhazip.com
!streamlit run app.py & npx localtunnel --port 8501